"use strict";
function cws_waves_bg( item ){

	//Variables declaration
	var SEPARATION = 120, AMOUNTX = 60, AMOUNTY = 60;
	var camera, scene, renderer;
	var particles, count = 0;
	var mouseX = 0, mouseY = 0;
	var windowHalfX = window.innerWidth / 2;
	var windowHalfY = window.innerHeight / 2;
	var color = jQuery(item).data('color');
        color = color.replace(/#/g, '');
        color = parseInt(color, 16);
    var interactive = jQuery(item).data('interactive');

	init();
	animate();
	
	/* 
    * - Init sphere, docs:
    * - https://github.com/mrdoob/three.js/blob/master/examples/webgl_points_waves.html
    * - https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene
    */ 
	function init() {
		camera = new THREE.PerspectiveCamera( 85, window.innerWidth / window.innerHeight, 1, 10000 );
		scene = new THREE.Scene();
		//
		var numParticles = AMOUNTX * AMOUNTY;
		var positions = new Float32Array( numParticles * 3 );
		var scales = new Float32Array( numParticles );
		var i = 0, j = 0;
		for ( var ix = 0; ix < AMOUNTX; ix ++ ) {
			for ( var iy = 0; iy < AMOUNTY; iy ++ ) {
				positions[ i ] = ix * SEPARATION - ( ( AMOUNTX * SEPARATION ) / 2 ); // x
				positions[ i + 1 ] = 0; // y
				positions[ i + 2 ] = iy * SEPARATION - ( ( AMOUNTY * SEPARATION ) / 2 ); // z
				scales[ j ] = 1;
				i += 3;
				j ++;
			}
		}
		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
		geometry.addAttribute( 'scale', new THREE.BufferAttribute( scales, 1 ) );

		var material = new THREE.ShaderMaterial( {
			uniforms: {
				color: { value: new THREE.Color( color ) },
			},
			vertexShader: document.getElementById( 'vertexshader' ).textContent,
			fragmentShader: document.getElementById( 'fragmentshader' ).textContent
		} );

		particles = new THREE.Points( geometry, material );
		scene.add( particles );
		renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		item.appendChild( renderer.domElement );
		if( interactive == true ){
			document.addEventListener( 'mousemove', onDocumentMouseMove, false );
		}
		window.addEventListener( 'resize', onWindowResize, false );
	}

	function onWindowResize() {
		windowHalfX = window.innerWidth / 2;
		windowHalfY = window.innerHeight / 2;
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
	}

	function onDocumentMouseMove( event ) {
		mouseX = event.clientX - windowHalfX;
		mouseY = event.clientY - windowHalfY;
	}

	function animate() {
		requestAnimationFrame( animate );
		render();
	}
	
	function render() {
		if( interactive == true ){
			camera.position.x += ( mouseX - camera.position.x ) * .05;
			camera.position.y += ( - mouseY - camera.position.y ) * .05;
		}
		camera.lookAt( scene.position );

		camera.position.z = 800;
		camera.position.y = 400;
		camera.position.x = 0;

		var positions = particles.geometry.attributes.position.array;
		var scales = particles.geometry.attributes.scale.array;
		var i = 0, j = 0;
		for ( var ix = 0; ix < AMOUNTX; ix ++ ) {
			for ( var iy = 0; iy < AMOUNTY; iy ++ ) {
				positions[ i + 1 ] = ( Math.sin( ( ix + count ) * 0.3 ) * 50 ) +
								( Math.sin( ( iy + count ) * 0.5 ) * 50 );
				scales[ j ] = ( Math.sin( ( ix + count ) * 0.3 ) + 1 ) * 8 +
								( Math.sin( ( iy + count ) * 0.5 ) + 1 ) * 8;
				i += 3;
				j ++;
			}
		}
		particles.geometry.attributes.position.needsUpdate = true;
		particles.geometry.attributes.scale.needsUpdate = true;
		renderer.render( scene, camera );
		count += 0.1;
	}
}

jQuery(".cws_waves_bg").each(function(){
    cws_waves_bg(this);
});